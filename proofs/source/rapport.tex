\input{./proofs/source/preambule.tex}
\addbibresource{./proofs/source/rapport.bib}
\usepackage{tkz-base}
\usepackage{algorithm}
\usepackage{algorithmic}
\setlength\parindent{0pt}

% \usepackage{graphicx,txfonts}




\title{Rapport de stage:\\
Arbitrages statistiques dans l'apprentissage automatique confidentiel.
}           
\author{{\sc Alexi Canesse}, L3 informatique fondamentale,\\École Normale Supérieure de Lyon\\
Sous la supervision d'{\sc Aurélien Garivier}, Professeur,\\ UMPA et École Normale Supérieure de Lyon}
\date{\today}          

\sloppy                  

\pgfplotsset{compat=1.16}

\begin{document}



\setmathfont{Latin Modern Math}
\setmathfont[range={\mathscr,\mathbfscr}]{XITS Math}

\maketitle
\newpage

\section{Méthode des histogrammes}

\subsection{AboveThreshold}

Répondre à de nombreuses requête est coûteux en confidentialité. Utiliser à algorithme naïf tel que le mécanisme de {\sc Laplace} ne permet pas de répondre à de nombreuses requêtes avec une bonne précision tout en préservant un bon niveau de confidentialité (\(\varepsilon\) doit être petit). Dans certains cas nous ne sommes néanmoins pas intéressé par les réponses numériques, mais uniquement intéressé par le fait qu'une réponse dépasse ou non un seuil définit. Nous allons voir que \mintinline{cpp}{AboveThreshold} permet cela tout en ne payant que pour les requêtes qui dépassent le seuil.

\label{AboveThreshold}
\begin{code}
    AboveThreshold(database, queries, threshold, epsilon){
        Assert("les requêtes sont toutes de sensibilité 1");
        result = 0;
        noisyThreshold = threshold + Lap(2/epsilon);
        for(querie in queries){
            nu = Lap(4/epsilon);
            if(querie(D) + nu > noisyThreshold)
                return result;
            else
                ++result;
        }
        return -1;
    }
\end{code}

L'algorithme venant d'être décrit renvoie l'indice de la première requête à dépasser le seuil si une telle requête existe. C'est une version adaptée de l'algorithme initialement décrit par {\sc Dwork } et {\sc Roth} dans \cite[page 57]{dwork2014the}. Icelui a du sens d'un point de vue informatique mais rend le formalisme mathématiques compliqué (les auteurs eux-même tombent dans ce travers) et nous n'utiliseront pas les légers avantages de leur version.\\
 
\theoreme{}\\
Pour tout ensemble de requêtes \(Q \in \left( \mathcal X^{(\N)} \to  \mathcal T \right)^{\N}\) de sensibilité \(1\), tout seuil \(T \in \R\), tout \(\varepsilon > 0\), \(M : x \in \mathcal X^{(\N)} \mapsto \) \mintinline{cpp}{AboveThreshold(x, Q, T, epsilon)} est \(\varepsilon\)-\textit{differentially private}.\\

\textit{\textbf{Remarque:} La démonstration est une réécriture de celle du livre de référence \cite[page57]{dwork2014the}. Une réécriture était nécessaire car cette démonstration présente de nombreux points limites en terme de rigueur mathématiques et de detail pas suffisant sur certains points non triviaux.}\\ 

\textit{Démonstration}:\\
Soit \(D, D' \in \mathcal X^{(\N)}\) tels que \(||D - D'|| \leq 1\), \(\{f_i\}_i = Q \in \left( \mathcal X^{(\N)} \to  \mathcal T \right)^{\N}\) un ensemble de requêtes de sensibilité \(1\), \(T \in \R\) un seuil, et \(\varepsilon > 0\). On pose alors \(A\) la variable aléatoire \mintinline{cpp}{AboveThreshold(D, Q, T, epsilon)} et \(A'\) la variable aléatoire \mintinline{cpp}{AboveThreshold(D', Q, T, epsilon)}.\\

Soit alors \(k \in \N\). \textit{Montrons que \(\mathbb P (A = k) \leq \mathbb P(A' = k)\)}. En reprenant les notations de l'algorithme [\ref{AboveThreshold}], on fixe les éléments \((\nu_i)_{i {\color{magenta} <} k}\) (qui suivent une loi de {\sc Laplace} de paramètre \(4/\varepsilon\)).\\


On pose alors
\[
    \left\{ 
        \begin{array}[]{rl}
            g_k & = \max_{i {\color{magenta} <} k} \left\{ f_i(D) + \nu_i\right\}\\
            g_k' & = \max_{i {\color{magenta} <} k} \left\{ f_i(D') + \nu_i\right\}\\
        \end{array}
    \right.    
\]

Ces grandeurs représente la valeur plus grande comparée au seuil bruité avant l'indice \(k\) dans le cas de l'execution sur \(D\) et de l'execution sur \(D'\). Les probabilité qui suivent seront prisent sur les deux variables aléatoires non fixées \(\nu_k\) et \(\hat T\) qui est la valeur du seuil bruitée. On pose enfin, pour tout \(i \in \N\),
\[
    \left\{ 
        \begin{array}[]{rl}
            y_i & = f_i(D)\\
            y_i' & = f_i(D')\\
        \end{array}
    \right.    
\]


On note alors que, en notant \(l_2\) la densité de la loi de {\sc Laplace} de paramètre \(2/\varepsilon\) et \(l_4\) celle de paramètre \(4/\varepsilon\),
\begin{align*}
    \mathbb P(A = k) & = \mathbb P(\hat T \in ]g_k, y_k + \nu_k])\\
    & = \int_{\R} \mathbb P(\hat T \in ]g_k, y_k + \nu])l_4(\nu) \dt \nu \\
    & = \int_{\R}\int_{g_k}^{y_k + \nu} l_2(t)l_4(\nu) \dt t \dt \nu 
\end{align*}

On effectue alors un premier changement de variable affine 
\[
    \hat t = t + g_k - g_k'    
\]

On obtient donc 
\begin{align*}
    \mathbb P(A = k) & = \int_{\R}\int_{g_k}^{y_k + \nu} l_2(\hat t - g_k + g_k')l_4(\nu) \dt  t \dt \nu\\
    & = \int_{\R}\int_{g_k'}^{y_k + \nu - g_k + g_k'} l_2(\hat t )l_4(\nu) \dt  t \dt \nu\\
\end{align*}

Il est alors temps de faire un second changement de variable affine
\[
    \hat \nu = \nu + g_k - g_k' + y_k' - y_k   
\]

Ainsi,
\begin{align*}
    \mathbb P(A = k) & = \int_{\R}\int_{g_k'}^{y_k + \nu - g_k + g_k' } l_2(\hat t )l_4(\hat\nu - g_k + g_k' - y_k' + y_k) \dt \hat t \dt \nu\\
    & = \int_{\R}\int_{g_k'}^{y_k + \nu  - g_k +g_k'  + g_k - g_k' +y_k' - y_k} l_2(\hat t )l_4(\hat\nu) \dt  t \dt \nu\\
    & = \int_{\R}\int_{g_k'}^{y_k' + \nu } l_2(\hat t )l_4(\hat\nu) \dt t \dt \nu\\
\end{align*}

Par définition de \(l_2\) et \(l_4\) nous avons donc
\begin{align*}
    \mathbb P(A = k) & =  \int_{\R}\int_{g_k'}^{y_k' + \nu } \exp\left(\dfrac{|\hat t|\varepsilon}{2}\right)\exp\left(\dfrac{|\hat\nu|\varepsilon}{4}\right) \dt t \dt \nu\\
\end{align*}

L'inégalité triangulaire assure alors que 
\begin{align*}
    \mathbb P(A = k) & \leq  \int_{\R}\int_{g_k'}^{y_k' + \nu } \exp\left(\dfrac{|\hat t - t|\varepsilon}{2}\right)\exp\left(\dfrac{|t|\varepsilon}{2}\right)\exp\left(\dfrac{|\hat\nu - \nu|\varepsilon}{4}\right)\exp\left(\dfrac{|\nu|\varepsilon}{4}\right) \dt t \dt \nu\\
    & =  \int_{\R}\int_{g_k'}^{y_k' + \nu } \exp\left(\dfrac{| g_k - g_k' |\varepsilon}{2}\right)\exp\left(\dfrac{|t|\varepsilon}{2}\right)\exp\left(\dfrac{|g_k - g_k' + y_k' - y_k |\varepsilon}{4}\right)\exp\left(\dfrac{|\nu|\varepsilon}{4}\right) \dt  t \dt \nu\\
\end{align*}

Les requêtes étant de sensibilité \(1\), nous avons 
\[
    \left\{ 
        \begin{array}[]{rlc}
            2 & \geq |g_k - g_k'| + |y_k' - y_k | & \geq|g_k - g_k' + y_k' - y_k | \\
            1 & = | g_k - g_k' | \\
        \end{array}
    \right.    
\]

Enfin, la croissance de l'intégrale assure que 
\begin{align*}
    \mathbb P(A = k) & \leq  \int_{\R}\int_{g_k'}^{y_k' + \nu } \exp\left(\dfrac{\varepsilon}{2}\right)\exp\left(\dfrac{|t|\varepsilon}{2}\right)\exp\left(\dfrac{\varepsilon}{2}\right)\exp\left(\dfrac{|\nu|\varepsilon}{4}\right) \dt  t \dt \nu\\
    & = \exp\left(\dfrac{2\varepsilon}{2}\right)  \int_{\R}\int_{g_k'}^{y_k' + \nu }\exp\left(\dfrac{|t|\varepsilon}{2}\right)\exp\left(\dfrac{|\nu|\varepsilon}{4}\right) \dt  t \dt \nu\\
    & = \exp\left(\varepsilon\right) \int_{\R}\int_{g_k'}^{y_k' + \nu }l_2(t)l_4(\nu) \dt  t \dt \nu\\
    & = \exp\left(\varepsilon\right) \int_{\R} \mathbb P(\hat T \in ]g_k', y_k' + \nu]) l_4(\nu) \dt \nu\\
    & = \exp\left(\varepsilon\right) \mathbb P(\hat T \in ]g_k', y_k' + \nu_k]) \\
    & = \exp\left(\varepsilon\right) \mathbb P(A' = k)
\end{align*}




\subsection{La méthode des histogramme}

La méthode des histogramme est une méthode que nous avons proposé durant ce stage. Il s'agit d'une instanciation particulière de \mintinline{cpp}{AboveThreshold} permettant de calculer l'ensemble des déciles (ou n'importe quel quantiles). Une transformation affine permet d'obtenir la réponse finale à partir de la réponse du mécanisme.

\begin{code}
    HistogramMethod(database, epsilon, steps, a, b){
        /* composition theorem */
        epsilon /= 9;

        result = {};
        for(d in {1 ... 9}){ /* which decile */
            T = d*card(database)/10;
            for(i in {1 ... steps}){
                fi = x -> card({element in x | element < i*(b-a)/steps});
                queries.push_back(fi);
            }
            T = d*card(database)/10;
            result.push_back(AboveThreshold(database, queries, T, epsilon)
                                *(b-a)/steps});
        }
        return result;
    }
\end{code}


Les entrée \(a\) et \(b\) donnent une minoration et une majoration de l'ensemble des valeurs d'entrées. L'algorithme découpe alors l'intervalle \([a,b]\) en \mintinline{cpp}{steps} intervalles de même tailles. Pour chaque décile, l'entier renvoyé par \mintinline{cpp}{Abovethreshold} est l'indice de la première valeur à dépasser ce décile.  

\definecolor{mycolor}{RGB}{109,7,26}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
    \draw[mycolor,->] (-7,0) -- (7,0);
    % \draw[white] (-1.425,0) -- (-1.325,0);
    \filldraw[mycolor] (-6,0) circle (2pt) node[below]{$0$};
    \filldraw[mycolor] (-3,0) circle (2pt) node[below]{\(1/4\)};
    \filldraw[mycolor] (0,0) circle (2pt) node[below]{\(1/2\)};
    % \draw[mycolor] (-1.5,-0.3) -- (-1.35, 0.3);
    % \draw[mycolor] (-1.4,-0.3) -- (-1.25, 0.3);
    \filldraw[mycolor] (3,0) circle (2pt) node[below]{3/4};
    \filldraw[mycolor] (6,0) circle (2pt) node[below]{1};
    % \filldraw[red] (2,0) circle (2pt) node[above]{$n$};
    \end{tikzpicture}
    \caption{Le découpage pour \(a = 0\), \(b = 1\), \mintinline{cpp}{steps} = 4}
\end{figure}

\theoreme{}\\
\mintinline{cpp}{HistogramMethod} est \(\varepsilon\)-\textit{differentially private}.\\


\textit{Démonstration:} Les requêtes envoyé par l'algorithme à \mintinline{cpp}{AboveThreshold} sont bien de sensibilité 1. Chacun des neuf appels à cette fonction est donc \(\varepsilon/9\)-\textit{differentially private}. Le théorème de composition assure alors que \mintinline{cpp}{HistogramMethod} est \(\varepsilon\)-\textit{differentially private}.\\

Maintenant que nous avons vu que cet algorithme est bien \textit{differentially private}, nous allons essayer d'évaluer sa précision. Cela ne sera pas évident car la précision de l'algorithme dépend beaucoup du jeu de donné en entré.\\




\lemme{\mintinline{cpp}{AboveThreshold} est \((\alpha, \beta)-accurate\)}\\
Pour tout \(\beta \in ]0,1[\), tout \(x \in \mathcal X^{(\N)}\), tout \(\{f_i\}_i = Q \in \left( \mathcal X^{(\N)} \to  \mathcal T \right)^{\N}\), tout \(\varepsilon > 0\), tout \(T \in \R\),  en posant \(\alpha = 8\left( \log(k) + \log(2/\beta) \right)/\varepsilon\) et \(k = \) \mintinline{cpp}{AboveThreshold(x, Q, T, epsilon)}, on a, en reprenant les notations de l'algorithme,
\[
    \mathbb P \left( \forall i < k \  f_i(x) + \nu_i < T + \alpha \wedge f_k(x) + \nu_k > T - \alpha \right) \geq 1 - \beta
\]

\textit{\textbf{Remarque:} Ce lemme est due à \cite[page 61]{dwork2014the}. Nous reprenons aussi la démonstration ici car la démonstration originale ne nous semble pas assez claire et trop bancale mathématiquement.}\\

\textit{Démonstration:} Reprenons les notations de l'énoncé. Montrons déjà qu'il suffit de démontrer que 
\begin{align}
    \label{accu_lemme}
    \mathbb P\left( \max_{i \leq k} |\nu_i| + |T - \hat T| < \alpha  \right)  \geq 1 - \beta   
\end{align}
où \(\hat T\) est le seuil bruité défini à la ligne 4 de l'algorithme [\ref{AboveThreshold}]. Or, nous avons, en posant pour tout \(i \leq k\), \(y_i = f_i(x)\)
\[
    y_k + \nu_k \geq \hat T \overset{\text{IT}}{\geq} T - |T-\hat T|
\]

\textit{Mutatis mutandis} 
\[
    \forall i < k \quad y_i \leq \hat T + |\nu_i| \leq T + |T - \hat T| + |\nu_i|  
\]

Ainsi,
\[
    \mathbb P \left( \forall i < k \  f_i(x) + \nu_i < T + \alpha \wedge f_k(x) + \nu_k > T - \alpha \right) \geq 1 - \beta
\]

\textit{Démontrons enfin (\ref{accu_lemme})}! La variable aléatoire \(T-\hat T\) suit une loi de {\sc Laplace} de paramètre \(2/\varepsilon\). Ainsi,
\[
    \mathbb P \left( |T - \hat T| \geq \dfrac{\alpha}{2} = \dfrac{\alpha \varepsilon}{4}\dfrac{2}{\varepsilon} \right) = \exp\left( -\dfrac{\varepsilon \alpha}{4} \right) = \exp\left( -2\left( \log k + \log \dfrac{2}{\beta} \right) \right) \leq \exp\left( -2\left(\log \dfrac{2}{\beta} \right) \right) \leq \dfrac{\beta}{2}
\]

De même,
\[
    \mathbb P \left( \max_{i} |\nu_i| \geq \dfrac{\alpha}{2} \right) \leq \sum\limits_{j = 1}^k \mathbb P \left( |\nu_j| \geq \dfrac{\alpha}{2} \right) = k \exp\left( -\dfrac{-\alpha\varepsilon}{8} \right) = k \exp\left( -\log k - \log\dfrac{2}{\beta} \right) = \dfrac{k}{k} \dfrac{\beta}{2}
\]

Enfin, 
\begin{align*}
    \mathbb P\left( \max_{i \leq k} |\nu_i| + |T - \hat T| < \alpha  \right) & \geq \mathbb P\left( \max_{i \leq k} |\nu_i| < \dfrac{\alpha}{2} \ \wedge \ |T - \hat T| < \dfrac{\alpha}{2} \right)\\
    & = 1 - \mathbb P\left( \max_{i \leq k} |\nu_i| \geq \dfrac{\alpha}{2} \ \cup \ |T - \hat T| \geq \dfrac{\alpha}{2} \right)\\
    & \geq 1 - \mathbb P\left( \max_{i \leq k} |\nu_i| \geq \dfrac{\alpha}{2}\right) - \mathbb P \left(|T - \hat T| \geq \dfrac{\alpha}{2} \right)\\
    &\geq 1 - \dfrac{\beta}{2} - \dfrac{\beta}{2}
\end{align*}

Finalement, 
\[
    \mathbb P\left( \max_{i \leq k} |\nu_i| + |T - \hat T| < \alpha  \right)  \geq 1 - \beta
\]

Ce qui démontre bien (\ref{accu_lemme}) et donc le lemme.\\

\subsubsection{Analyse de complexité}

La complexité de \mintinline{cpp}{AboveThreshold} est de l'ordre de la somme des complexité des requêtes sur le jeu de données d'entré. En notant \(n\) la taille de la base de donnée, les requêtes envoyé à \mintinline{cpp}{AboveThreshold} par \mintinline{cpp}{HistogramMethod} sont toute de complexité linéaire en \(n\). La variable \mintinline{cpp}{step} a aussi pour valeur le nombre de requêtes envoyées que l'on nommera \(k\). L'algorithme a alors une complexité en \(\O(nk)\).

\subsubsection{Analyse de précision - le cas de la distribution uniforme}

Nous allons évaluer la précision de l'algorithme à l'aide de l'erreur quadratique moyenne entre la valeur renvoyé par le programme et la valeur attendue. Il y a plusieurs manière de penser ce qu'est la valeur attendue: elle pourrait être la valeur des déciles de l'échantillons d'entré. Néanmoins, elle peut tout aussi bien être l'ensemble des déciles de la loi. En effet, nous cherchons à répondre à des questions de statistique, l'entré peut-être un simple échantillon ``représentatif'';  au quel cas nous sommes principalement intéressé par les réponses statistiques sur l'ensemble de la population et non juste sur notre échantillon.\\

Ces deux choix ont un réel sens. Nous avons d'abord essayé d'évaluer les performances de l'algorithme dans le premier cas. Les calculs était difficiles et menaient à des résultats difficilement exploitables. Nous avons donc choisi de réaliser les calculs sur la seconde option afin de pouvoir mener des calculs légèrement plus simples et ainsi avoir des résultats.\\






\newpage
\printbibliography
% \vspace{30px}
% \vspace{15px}


\end{document} 